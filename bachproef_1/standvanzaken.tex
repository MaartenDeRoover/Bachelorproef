\chapter{Stand van zaken}
\label{ch:stand-van-zaken}
\section{Belangrijkste testtypes voor webdevelopment}
% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.
Dit hoofdstuk bespreekt de belangrijkste testtypes voor webdevelopment: unit testen, integratie testen en functionele testen. In het volgende hoofdstuk wordt dieper ingegaan op het functionele testtype, het testtype dat het belangrijkst is voor dit onderzoek.

\subsection{Unit testen}

Unit testen zijn de soort testen die er voor zorgen dat elke individuele component van een applicatie werkt. Met een unit wordt een module, een functie of een specifiek stukje code van een applicatie bedoeld, \textcite{Elliott2016}.
\newglossaryentry{dummy}
{
    name=Dummy,
    description={Een dummy is een object dat nooit echt gebruikt wordt. Dummies worden meestal gebruikt voor het opvullen van parameterlijsten, \textcite{Fowler2007}}
    plural={dummies}
}
\newglossaryentry{fake}
{
    name=Fake,
    description={Een fake is een object dat werkende implementaties heeft maar dat gebruik maakt van een kortere weg waardoor ze niet ideaal zijn voor productie, \textcite{Fowler2007}}
    plural={fakes}
}
\newglossaryentry{stub}
{
    name=Stub,
    description={Een stub wordt tijdens het testen gebruikt om een standaard antwoord te geven op een oproep, \textcite{Fowler2007}}
    plural={stubs}
}
\newglossaryentry{spy}
{
    name=Spy,
    description={Een spy is een \gls{stub} die informatie geeft over wanneer die opgeroepen werd, \textcite{Fowler2007}}
    plural={spies}
}
\newglossaryentry{mock}
{
    name=Mock,
    description={Een mock is een object dat voorgeprogrammeerd werd met oproepen die ze verwachten te krijgen in gedachten, \textcite{Fowler2007}}
    plural={mocks}
}
Een unit test zou simpel en snel moeten zijn en zou wanneer de test faalt duidelijk moeten zeggen waar de fout ligt en wat het probleem is. Om unit testen zo snel mogelijk te maken wordt er vaak gebruik gemaakt van \glspl{dummy}, \glspl{fake}, \glspl{stub}, \glspl{spy} en \glspl{mock}. 

Unit testen zouden een vangnet moeten zijn die het grootste deel van de code omvat. Ze zouden ontwikkelaars het vertrouwen moeten geven om aanpassingen te maken omdat ze weten dat als er iets misloopt ze een duidelijk overzicht gaan krijgen van wat waar misliep, \textcite{Zilberfeld2013}.

Unit testen houden zeker niet alle bugs tegen maar ze vergroten de kans dat een nieuw stuk code correct werkt en ze zorgen er voor dat het debuggen van code minder tijd in beslag neemt.

\subsection{Integratie testen}

Integratie testen zijn de soort testen die nagaan of de verschillende componenten (units) correct met elkaar samenwerken. Bij integratietesten komen alle verschillende componenten samen en worden die in hun geheel getest. Hier wordt dus geen gebruik gemaakt van \glspl{mock} zoals in unit tests, \textcite{Reselman2017}.

Integratietesten maken vaak gebruik van \glspl{API} van derden zoals een API die dingen wegschrijft naar een databank. Integratietesten hebben hierdoor vaak een netwerk connectie nodig waardoor het uitvoeren van deze testen veel trager verloopt dan het uitvoeren van unit testen. Unit testen en integratietesten hou je het best gescheiden omdat het voor unit testen belangrijk is dat deze zo snel mogelijk zijn, \autocite{Elliott2016}.

\subsection{Functionele testen}

Functionele testen, ook wel browser testen, UI testen, front-end testen of end-to-end testen genoemd, zijn de soort testen die de applicatie testen vanuit het oogpunt van de gebruiker. Functionele testen worden ook wel end-to-end testen genoemd omdat de volledige applicatie van front-end tot back-end correct moet werken voor het slagen van deze testen.

Functionele testen doorlopen de processen die de gebruiker ook doorloopt, zoals bijvoorbeeld het inloggen op een website, het navigeren naar een bepaalde pagina via het menu, het invullen van een formulier op een website,... Functionele testen krijgen hiervoor een input mee en een verwachting van wat de output zal zijn en gaat dan na of dit ook daadwerkelijk zo is.

\section{Soorten tools voor het functioneel testen van een website}

In dit gedeelte wordt onderscheid gemaakt tussen drie soorten tools die gebruikt worden bij het functioneel testen van een website. De eerste soort die besproken wordt is voor dit onderzoek het belangrijkst. In het volgende hoofdstuk wordt de onderverdeling van die eerste soort nader toegelicht en worden de tools die in dit onderzoek vergeleken worden, besproken.

\subsection{Tools voor het maken van functionele testen}
\newglossaryentry{WebDriver}
{
    name=WebDriver,
    description={Een WebDriver is een framework voor de automatisatie van een browser. Een WebDriver maakt het mogelijk om gebruikersinteracties zoals het navigeren naar een pagina of het invullen van een formulier te automatiseren. Voorbeelden van WebDrivers zijn: Selenium WebDriver, ChromeDriver, GeckoDriver, Microsoft WebDriver,..}
}
\newglossaryentry{assertie}
{
    name=Assertie,
    text=assertie,
    description={Een assertie is een bewering. Tijdens het schrijven van testen worden asserties gemaakt over de output en vervolgens wordt nagegaan of de werkelijke output hetzelfde is als de beweerde output}
    plural={asserties}
}
De eerste soort zijn de tools die je nodig hebt voor het maken van functionele testen. Deze soort wordt nog eens opgesplitst in drie verschillende categorieën: 
\begin{itemize}
\item De all-in-one tools, dit zijn de tools die volledig onafhankelijk werken en waarvoor je dus geen extra tools, frameworks of libraries nodig hebt.
\item De tools waarvoor je nog een \gls{WebDriver} nodig hebt voor het kunnen uitvoeren van je testen.
\item De libraries die nood hebben aan een testing framework en \gls{assertie} \gls{library} om als volwaardige testing tool te kunnen beschouwd worden.
\end{itemize}
Meer over deze verschillende soorten in het volgende deel.
\subsection{Tools voor cross-browser testing}

Deze soort zijn de tools die je nodig hebt om je functionele testen op verschillende besturingssystemen, browsers en formaten uit te voeren. Deze tools maken het volgende mogelijk: 
\begin{itemize}
\item Het testen van een website op verschillende browsers zoals Google Chrome, Mozilla Firefox, Internet Explorer, Safari, \ldots
\item Het testen van een website op verschillende versies van browsers.
\item Het testen van een website op browsers op verschillende besturingssystemen zoals Windows, MacOS, Linux, \ldots
\item Het testen van een website op verschillende formaten zoals het smartphone formaat, tablet formaat, desktop formaat, \ldots
\end{itemize}
\newglossaryentry{Selenium-Grid}
{
    name=Selenium-Grid,
    description={Een Selenium-Grid is een netwerk van verschillende browsers, versies van browsers, browsers op verschillende besturingssystemen en verschillende formaten van browsers die gebruik maken van het Selenium framework}
}
Deze tools bieden vaak nog extra diensten aan waarvan het in de cloud uitvoeren van testen een van de belangrijkste is. Dit zorgt er voor dat testen niet meer lokaal uitgevoerd worden maar wel op afstand in de cloud. Hierdoor is het parallel uitvoeren van testen mogelijk. Deze tools maken meestal gebruik van een \gls{Selenium-Grid}. In het volgende hoofdstuk wordt dieper ingegaan op Selenium en bibliotheken die Selenium uitbreiden.
\newglossaryentry{snapshot}
{
    name=Snapshot,
    text=snapshot,
    description={Een snapshot is een afbeelding van de huidige staat van het systeem}
    plural={snapshots}
}

Een andere dienst die deze tools kunnen aanbieden zijn het nemen van \glspl{snapshot} na het falen van een test. Aan de hand van deze snapshots kan je specifiek gaan debuggen omdat je de exacte staat hebt van het systeem waar de test faalde.

Voorbeelden van deze soort tools zijn SauceLabs, BrowserStack, CrossBrowserTesting, Testingbot en BrowseEmAll.

\subsection{Tools voor Behavior Driven Development}
\newglossaryentry{BDD}{
	type=\acronymtype,
    name={BDD},
    description={Behavior Driven Development},
}
\newglossaryentry{user story}
{
    name=User story,
    description={Een user story is een beschrijving van wat een bepaalde gebruiker wil en waarom},
    plural={user stories}
}
De laatste soort zijn optionele tools die een abstractielaag toevoegen bovenop de andere tools om Behavior Driven Development, gedragsgerichte ontwikkeling, mogelijk te maken. \gls{BDD} is een methodologie waarbij de focus ligt op het gedrag van de gebruiker. De verschillende gedragen van de gebruiker (scenario's)  worden meestal vastgelegd aan de hand van \glspl{user story}.

Deze soort tools zijn optioneel en dienen enkel om het lezen en schrijven van testen te vereenvoudigen. Het voordeel van deze tools is dat ze het mogelijk maken voor niet-programmeurs om testen te schrijven. Het nadeel is dat ze extra complexiteit toevoegen die vaak overbodig is.

Voorbeelden van dergelijke tools zijn Cucumber.js en CodeceptJS.

\section{Tools voor het maken van functionele testen}
In dit deel worden eerst de tools, frameworks en libraries besproken die een ondersteunende rol hebben voor de tools die in dit onderzoek getest worden. Daarna worden per categorie de tools besproken die in het volgende hoofdstuk, Methodologie, getest worden.

\subsection{Ondersteunende tools, frameworks en libraries}

\subsubsection{ChromeDriver}
ChromeDriver is een opensource tool voor het geautomatiseerd testen van websites. Concreet wil dit zeggen dat ChromeDriver een standalone server is die gebruik maakt van een Chrome of Chromium browser voor het uitvoeren van geautomatiseerde testen. ChromeDriver is beschikbaar op Windows, MacOS en Linux, dit onderzoek maakt gebruik van ChromeDriver 2.41, \textcite{ChromeDriver2018}.

\subsubsection{Mocha}
Mocha is een opensource Node.js Javascript framework voor het maken van asynchrone testen, \autocite{Mocha}. Mocha wordt in dit onderzoek gebruikt als standaard testing framework voor de tools die nog geen testing framework hebben.

\subsubsection{Chai}
Chai is een opensource Node.js library voor het maken van asserties in testen. Met Chai is het mogelijk om zowel BDD als TDD asserties te maken, \autocite{Chai}. Chai wordt in dit onderzoek gebruikt als standaar assertie library voor de tools die dit nog niet bevatten.

\subsection{Electron}

Electron is een framework dat gebruik maakt van Chromium en Node.js en dat dient voor het maken van applicaties met webtechnologieën als JavaScript, HTML en CSS. Electron is opensource en beschikbaar op zowel Windows, MacOS als Linux.

\subsection{All-in-one tools}

Dit zijn tools die geen frameworks of libraries van derden nodig hebben om te werken, deze tools zijn zelfstandig en bevatten het hele pakket. Het voordeel van deze tools is dat je je testen kan schrijven en uitvoeren zonder het downloaden van extra software. Ook de extra complexiteit die wordt toegevoegd bij de integratie van verschillende tools met elkaar valt hier dus weg. De twee die in dit onderzoek besproken en vergeleken worden van dit type zijn: TestCafé en Cypress.

\subsubsection{TestCafé}
TestCafé \autocite{Testcafe}, niet te verwarren met TestCafé Studio, is een  gratis opensource node.js tool voor het automatiseren van end-to-end web testen ontwikkelt door DevExpress. TestCafé Studio daarentegen is een IDE die ook door DevExpress ontwikkelt werd en die het mogelijk maakt om testen te maken zonder code te moeten schrijven. TestCafé Studio is betalend en hierop wordt in dit onderzoek niet verder ingegaan. 

TestCafé werkt op volgende besturingssystemen: Windows, MacOS en Linux, en kan gebruik maken van volgende browsers: Google Chrome, Internet Explorer, Microsoft Edge, Mozilla Firefox, Safari, Android browser, Safari. Je kan ook gebruik maken van programma's zoals SauceLabs, BrowserStack of CrossBrowserTesting voor je testen in de cloud op meerdere browsers en formaten uit te voeren.

Het schrijven van testen met TestCafé gebeurt in JavaScript of TypeScript. TypeScript is een superset van JavaScript dit wil zeggen dat JavaScript een deelverzameling is van TypeScript en beiden kunnen door elkaar gebruikt worden. Een kenmerk van TestCafé is dat het een manier implementeert om slim te testen. Je kan wachttijden instellen voor elementen om te verschijnen op de pagina. Van zodra het element verschijnt gaat de test verder en als de wachttijd overschreden wordt dan faalt de test. Dit zorgt er voor dat je geen verplichte slaaptijden moet inbouwen om te wachten op elementen die niet direct tevoorschijn komen. De code zelf is goed leesbaar omdat de API die gebruikt wordt voor elementen te selecteren en asserties te maken eenvoudig, leesbaar en logisch is. Verder kan je ook gebruik maken van het Page Object patroon om je testen te vereenvoudigen en dubbele code te vermijden. Het Page Object patroon laat je toe om de pagina die je wil testen te abstraheren en in de code van de test te referen naar elementen van de pagina die je wil testen. 

Een ander belangrijk kenmerk van TestCafé is de mogelijkheid om testen parallel uit te voeren. Het is mogelijk om meerdere instanties van dezelfde browser of van verschillende browsers op te zetten. Vervolgens wordt bij het uitvoeren van je \gls{testsuite} je testen over deze verschillende instanties verdeeld.

TestCafé rapporteert automatisch alle JavaScript errors die tegen gekomen worden tijdens het uitvoeren van een test op de verschillende webpagina's die bezocht werden. 

TestCafé heeft ook een plugin genaam TestCafé live waarmee je testen kan schrijven en aanpassen terwijl deze worden uitgevoerd. Van zodra je een aanpassing hebt gemaakt stopt het de huidige test indien die nog bezig was en start het de test gewoon opnieuw. Dit vereenvoudigt het proces van testen schrijven en debuggen sterk. 

Om TestCafé te integreren in je \gls{CI} systeem is er op de site van TestCafé zelf voldoende documentatie hoe je dit moet doen en zijn er ook door de community plugins ontwikkelt om dit proces te vereenvoudigen. Op de site van TestCafé zelf vind je documentatie voor de implementatie in volgende continue integratie systemen: AppVeyor, CircleCI, Jenkins, TeamCity en Travis. TestCafé testen kunnen ook uitgevoerd worden tijdens het ontwikkelingsproces door je testen via plugins toe te voegen aan Gulp of Grunt. Gulp en Grunt zijn automatisatie tools die voor vele verschillende doeleinden kunnen gebruikt worden. Een voorbeeld hiervan is het automatisch compileren van SASS code naar CSS code bij het opslaan van een SASS bestand.

\subsubsection{Cypress}
Cypress is de tweede all-in-one tool die besproken wordt voor het maken van functionele testen en is net zoals TestCafé opensource en heeft een nieuwe architectuur die niet bovenop Selenium werd gebouwd. Cypress is opnieuw het volledige pakket en is dus niet afhankelijk van servers of drivers voor de installatie of configuratie.

Cypress testen worden volledig in JavaScript geschreven en Cypress heeft zijn eigen API voor het automatiseren van de browser of voor de interne configuratie van Cypress te besturen. Cypress heeft ook een automatisch functie ingebouwd om te wachten op elementen om te verschijnen of om asserties te maken. Hierdoor moet je geen sleeps inbouwen en spaar je tijd uit.

De sterkte van Cypress zit hem in de eenvoud om testen te schrijven en debuggen. Dit heeft enkele redenen, de eerste is dat je het uitvoeren van Cypress testen live kan meevolgen en dat indien je een aanpassing maakt de test opnieuw start. Cypress heeft een zeer gebruiksvriendelijke eigen UI voor het uitvoeren en meevolgen van testen. De tweede reden is dat tijdens het live uitvoeren van testen je de logs van de command line in het linkerdeel van de UI kan zien waardoor je direct ziet als er iets misloopt met de samenhorende foutmelding. De derde reden is dat Cypress automatisch snapshots maakt tijdens het uitvoeren van testen. Deze worden vervolgens in de command log geplaatst en kan je op elke stap precies zien wat er gebeurt. De vierde en laatste reden is dat het met Cypress mogelijk is om screenshots te nemen nadat een test faalde of om de volledige uitvoering van de test te filmen. Hierdoor kan je nadat de test is uitgevoerd en gefaalt precies teruggaan naar het punt waar de test faalde om zo specifiek te debuggen.

Een ander kenmerk van Cypress is de mogelijkheid om gebruik te maken van spies of stubs zoals in unit testen. Stubs kan je gebruiken voor je netwerk verkeer zodat je je eigen server niet moet gebruiken.

De mogelijkheden om Cypress in te bouwen in je CI systeem zijn zeer ruim. Zo is Cypress al succesvol geïmplementeerd geweest in volgende systemen: Jenkins, TravisCI, CircleCI, CodeShip, GitLab, BuildKite, AppVeyor, Semaphore, Concourse, Solano, Docker.

Momenteel is cross-browser testing nog niet mogelijk met Cypress. Enkel varianten van de Chrome familie worden momenteel ondersteund. Cypress heeft wel plannen om in de toekomst meer browsers te ondersteunen, \textcite{Mann2017}. Anderzijds kan over het nut van cross-browser testen ook gediscussieerd worden. Cross-browser testen vergroot de kost en infrastructuur nodig voor het testen erg terwijl dit het vertrouwen slechts licht vergroot. Ook de kans dat een fout browserspecifiek is is zeer klein, \textcite{Mann2018}.

Parallel testen is ook niet mogelijk met enkel de Cypress client. Wel kan gebruik gemaakt worden van Docker om verschillende Docker containers op te zetten die parallel draaien en met Cypress testen uitvoeren.

\subsection{Frameworks die nood hebben aan en WebDriver}

Dit zijn frameworks die hun eigen syntax en tools voor \glspl{assertie} hebben maar die nog geen \gls{WebDriver} hebben voor het uitvoeren van deze testen. Voor het uitvoeren van testen met deze soort tools moet je dus nog een WebDriver van een derde partij voorzien zoals bijvoorbeeld de Selenium WebDriver, ChromeDriver of GeckoDriver. Voorbeelden van deze soort zijn Nightwatch en WebdriverIO.

\subsubsection{Nightwatch}

Nightwatch is een opensource Node.js framework voor het maken van functionele testen. Voor het uitvoeren van testen met Nightwatch heb je echter nood aan een WebDriver, Nightwatch ondersteunt ChromeDriver, GeckoDriver en Selenium Standalone Server.

Nightwatch maakt gebruik van de W3C WebDriver API voor het uitvoeren van commando's en asserties op DOM elementen. Hiermee kan je gebruik maken van CSS en XPATH selectors om elementen op de pagina te selecteren.

Het parallel uitvoeren van tests is mogelijk met Nightwatch, zo kan je verschillende instanties van dezelfde browser of van verschillende browsers aanmaken. Het aantal parallelle testen dat kan uitgevoerd worden is gelijk aan het aantal CPU's, heb je 4 CPU's dan kan je maximaal 4 testen parallel uitvoeren.

Een ander kenmerk van Nightwatch is dat het al een BDD library bevat en je dus geen gebruik moet maken van externe libraries zoals Cucumber.js of Codecept.js om Behavior Driven testen te schrijven.

Op vlak van cross-browser testing is de integratie van Nightwatch mogelijk met alle bekende cloud services zoals SauceLabs, BrowserStack, TestingBot of CrossBrowserTesting. Momenteel is Nightcloud, een cloud service specifiek voor Nightwatch, in ontwikkeling, \textcite{Nightcloud2017}.

Continue integratie met Nightwatch is mogelijk met alle bekende CI systemen zoals Teamcity, Jenkins, Hudson, CircleCI,... Voor de integratie van Nightwatch in het ontwikkelingsproces zijn plugins beschikbaar voor bijvoorbeeld de integratie met Gulp of Grunt.

Nightwatch wordt door de Drupal community ondersteund en is momenteel in de core van de pre-release van Drupal 8.6 opgenomen. Voordien werd door de Drupal community voornamelijk gebruik gemaakt van PhantomJS voor functionele testen maar nu PhantomJS niet meer onderhouden wordt is de community overgestapt op Nightwatch.

\subsubsection{WebdriverIO}
WebdriverIO is een opensource Node.js testing framework voor het maken van functionele testen. In tegenstelling tot Nightwatch laat WebdriverIO je BDD of TDD testing framework zelf kiezen. De frameworks die compatibel zijn met WebdriverIO en waaruit je dus kan kiezen zijn: Mocha, Jasmine en Cucumber. Deze testing frameworks worden aan de hand van Node.js adapter modules verbonden met WebdriverIO.

Standaard is het enkel mogelijk om testen in JavaScript te schrijven maar aan de hand van een Node pakket kan de functionaliteit van WebdriverIO uitgebreid worden om ook TypeScript te kunnen gebruiken. Elementen zijn met WebdriverIO gemakkelijk te selecteren met de CSS of XPATH selectors. WebdriverIO implementeert \$ en \$\$ functies die geketend worden om makkelijker elementen te selecteren. Dit kan gebruikt worden ter vervanging van ingewikkelde XPATH selectors.

Tijdens het uitvoeren van testen wordt er een verslag uitgeprint in de command line  over hoe deze testen verliepen. Dit verslag is aanpasbaar en er is keuze uit 10 verschillende reporters die de testverslagen anders uitprinten. Het is ook mogelijk om een zelfgemaakte reporter te gebruikten. WebdriverIO voorziet ook standaard een service die snapshots maakt bij het falen van testen.

Het parallel uitvoeren van testen is mogelijk en in het configuratiebestand van WebdriverIO kan je definiëren welke verschillende browsers er gebruikt moeten worden en hoeveel instanties van deze browsers.

Voor de ontwikkeling en het debuggen van testen voorziet WebdriverIO een REPL interface, hiermee is mogelijk om commando's uit te voeren in de command line en rechtstreeks in de browser te zien wat er gebeurt.

Op vlak van Cross-Browser testing voorziet WebdriverIO documentatie voor de integratie met de cloud services SauceLabs, Browserstack en TestingBot. Om WebdriverIO aan je lokaal ontwikkelingsproces toe te voegen bestaan er plugins voor de integratie met Gulp en voor de integratie met Grunt.

Op vlak van continue integratie is het mogelijk om WebdriverIO te integreren in je CI systeem. WebdriverIO voorziet enkel documentatie voor de integratie in Jenkins maar er zijn online voorbeelden te vinden over hoe de integratie verloop in andere systemen zoals TravisCI.

\subsection{Libraries voor webautomatisering}

Dit zijn libraries die in eerste plaats niet specifiek dienen voor testen maar wel voor webautomatisering. Deze libraries kunnen in combinatie met andere tools en frameworks gebruikt worden voor testen. Het eerste dat deze soort tools nodig heeft is een testing framework, de populairste voorbeelden hiervan zijn Mocha en Jasmine. Het tweede dat deze soort tools nodig heeft is een library voor asserties, het populairste voorbeeld hiervan is Chai. Aan de hand van deze twee soorten tools kunnen libraries zoals Puppeteer en Nightmare fungeren als een volwaardig test framework.

\subsubsection{Nightmare}

Nightmare is een library voor browser automatisatie origineel ontwikkelt door Segment maar later opensource geworden. Met de API van Nightmare is het mogelijk om gebruikersinteracties na te bootsen met simpele commando's zoals goto, type, click,... Nightmare werd oorspronkelijk ontwikkelt voor het automatiseren van taken op een website maar wordt vooral gebruikt voor het functioneel testen van websites en voor het crawlen van websites.

Nightmare testen worden geschreven in JavaScript.

Nightmare maakt gebruik van Electron en Electron maakt gebruik van Chromium. Dit wil zeggen dat testen of programma's die met Nightmare geschreven worden, uitgevoerd worden in een Chromium omgeving.

Twee handige tools voor het functioneel testen van een website met Nightmare zijn Niffy en Daydream. Niffy is een tool die bovenop Nightmare gebouwd is en die je helpt om veranderingen of bugs in de UI te ontdekken. Daydream is een Chrome extensie waarmee acties die uitgevoerd worden op een website omgezet worden in een Nightmare of Puppeteer script.

Op vlak van cross-browser testen zijn er geen mogelijkheden met Nightmare, Nightmare is enkel ontwikkelt voor de automatisatie van Electron.

De mogelijkheden in verband met het parallel uitvoeren van testen en continue integratie hangen niet van Nightmare af maar hangen wel af van het gebruikte testing framework. Concreet wil dit zeggen dat als het testing framework bijvoorbeeld geïntegreerd kan worden in Jenkins en de testen parallel kan uitvoeren dan kan dit ook met Nightmare.

\subsubsection{Puppeteer}
Puppeteer is een Node library voor het automatiseren van een Chrome of Chromium browser. Standaard voert Puppeteer een headless versie van Chrome of Chromium uit, maar er kan ingesteld worden dat een volledige zichtbare versie van Chrome of Chromium moet uitgevoerd worden. Puppeteer kan gebruikt worden voor alles waarvoor browser automatisatie vereist is, maar wordt voornamelijk gebruikt voor het crawlen van websites en voor het functioneel testen van websites.

Een van de standaard ingebouwde functies van Puppeteer voorziet de mogelijkheid om snapshots te nemen.

Op vlak van cross-browser testen zijn er geen mogelijkheden met Puppeteer, Puppeteer is enkel ontwikkelt voor de automatisatie van Chrome of Chromium. Wel kunnen cloud services gebruikt worden om testen in de cloud uit te voeren.

Het parallel uitvoeren van testen is mogelijk met Puppeteer maar wordt niet standaard voorzien. Deze functionaliteit kan wel gerealiseerd worden met tools die community heeft ontwikkelt zoals bijvoorbeeld de puppeteer-cluster library. Het integreren van Puppeteer in je CI systeem is mogelijk maar hier voorziet Puppeteer geen documentatie over.

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet er nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz. naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\TeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin, gebruik je \texttt{$\backslash${}textcite\{\}}.
%Soms wil je de auteur niet expliciet vernoemen, dan gebruik je \texttt{$\backslash${}autocite\{\}}. In de volgende paragraaf een voorbeeld van elk.

%\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.

%\lipsum[7-20]
